package {	import flash.display.MovieClip;	import flash.ui.Mouse;	import flash.events.MouseEvent;	import flash.events.Event;	import com.greensock.TweenLite;	import com.greensock.easing.Linear;	public class BrakeHandle extends MovieClip {		private var _step:uint;		private var _onAir:Boolean = false;		private const _increment:uint = 10;		const MAX_BRAKE_PRESSURE:uint = 275;		public static const END_ANIMATION:String = "BrakeHandleEndAnimation";		public function BrakeHandle():void {			this.addEventListener(Event.ADDED_TO_STAGE, onAddedToStage);		}		public function step():uint {			if (_onAir) {				return Math.ceil(this.rotation) * -1;			} else {				return this.rotation / _increment * -1;			}		}		public function setValue():void {			var step_txt:String,step_val:uint;			step_val = step();			if (step_val == 0) {				step_txt = "Run & Rel";				this.value_txt.textColor = 0x00CC00;			} else if ((step_val == 10 && !_onAir) || step_val == 100) {				step_txt = "Emergency";				this.value_txt.textColor = 0xCC0000;			} else {				if (_onAir) {					step_txt = Math.round(step_val * (MAX_BRAKE_PRESSURE / 70)) + "kPa";				} else {					step_txt = "Step " + step_val;				}				this.value_txt.textColor = 0x0000CC;			}			this.value_txt.text = step_txt;		}		public function stepTo(step:uint):void {			var rot:int;			if (step < 0 || step > 8) {				return;			}			if (step == 8) {				rot = -100;			} else {				rot = step * -10;			}			this.rotation = rot;			TweenLite.to(this, 0.5, {rotation:rot, ease:Linear.easeNone, onStart:onStartTween});			setValue();		}		public function setAir(onAir:Boolean):void {			this._onAir = onAir;		}		private function onStartTween():void {			dispatchEvent(new MouseEvent(END_ANIMATION));		}		private function onAddedToStage(event:Event) {			this.addEventListener(Event.REMOVED_FROM_STAGE, onRemovedFromStage);			this.addEventListener(MouseEvent.MOUSE_OVER, onMouseOver);			stage.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDownx);			stage.addEventListener(MouseEvent.MOUSE_UP, onMouseUpx);			this.removeEventListener(Event.ADDED_TO_STAGE, onAddedToStage);		}		private function onRemovedFromStage(event:Event):void {			this.removeEventListener(Event.REMOVED_FROM_STAGE, onRemovedFromStage);			stage.removeEventListener(MouseEvent.MOUSE_DOWN, onMouseDownx);			stage.removeEventListener(MouseEvent.MOUSE_UP, onMouseUpx);			this.removeEventListener(MouseEvent.MOUSE_OVER, onMouseOver);		}		private function onMouseOver(event:MouseEvent):void {			this.buttonMode = true;		}		private function onMouseDownx(event:MouseEvent):void {			if (event.target.name == "brakeHandle") {				stage.addEventListener(MouseEvent.MOUSE_MOVE, onMouseMovex);			}		}		private function onMouseMovex(event:MouseEvent):void {			var dx:int = stage.mouseX - this.x;			var dy:int = stage.mouseY - this.y;			var rot:int = Math.atan2(dy,dx) * 180 / Math.PI;			if (_onAir) {				if (checkRotation(rot)) {					this.rotation = rot;				}			} else {				if (rot % _increment == 0 && checkStep(rot / -10.0)) {					this.rotation = rot;				}			}			setValue();		}		private function onMouseUpx(event:MouseEvent):void {			if (stage.hasEventListener(MouseEvent.MOUSE_MOVE)) {				stage.removeEventListener(MouseEvent.MOUSE_MOVE, onMouseMovex);			}		}		private function checkStep(step:uint):Boolean {			return (step >= 0 && step <= 7) || step == 10;		}		private function checkRotation(rot:int):Boolean {			return (rot <= 0 && rot >= -70) || rot == -100;		}	}}